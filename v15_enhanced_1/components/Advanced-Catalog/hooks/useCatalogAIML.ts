/**
 * Advanced Catalog AI/ML Hooks
 * Maps to: ai_service.py, advanced_ai_service.py, ml_service.py, ai_routes.py, ml_routes.py
 * 
 * Comprehensive React hooks for AI/ML operations with React Query,
 * semantic analysis, machine learning models, and intelligent recommendations.
 */

import { useQuery, useMutation, useQueryClient, UseQueryResult, UseMutationResult } from '@tanstack/react-query';
import { catalogAIMLApiClient } from '../services/catalog-ai-ml-apis';
import type {
  SemanticAnalysisRequest,
  SemanticAnalysisResult,
  SemanticEmbedding,
  SimilarityCalculationRequest,
  SimilarityScore,
  RelationshipExtractionRequest,
  ExtractedRelationship,
  AutoDescriptionRequest,
  GeneratedDescription,
  AssetRecommendationRequest,
  AssetRecommendation,
  AutoClassificationRequest,
  AutoClassificationResult,
  SensitiveDataDetectionRequest,
  SensitiveDataDetectionResult,
  PatternRecognitionRequest,
  RecognizedPattern,
  AnomalyDetectionRequest,
  DetectedAnomaly,
  SchemaEvolutionDetectionRequest,
  SchemaEvolutionResult,
  PredictiveAnalyticsRequest,
  PredictiveInsight,
  MLModelTrainingRequest,
  MLModelTrainingResult,
  MLModelConfig,
  MLModel,
  MLModelMetrics,
  MLModelPrediction,
  ModelVersioning,
  ModelDeployment,
  ContextualIntelligenceRequest,
  ContextualInsight,
  AIInsight,
  MLPipeline,
  ModelRegistry,
  FeatureStore,
  DataDrift,
  ModelDrift,
  ModelExplainability,
  BiasDetection,
  FairnessMetrics,
} from '../types/ai-ml.types';

import type {
  IntelligentDataAsset,
  SemanticRelationship,
} from '../types/catalog-core.types';

import { useToast } from '@/components/ui/use-toast';
import { useCallback, useEffect, useState, useRef } from 'react';
import { useDebounce } from 'use-debounce';

// ===================== SEMANTIC ANALYSIS HOOKS =====================

/**
 * Hook for performing semantic analysis
 */
export function useSemanticAnalysis(
  request: SemanticAnalysisRequest | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<SemanticAnalysisResult, Error> {
  const [debouncedRequest] = useDebounce(request, 500);

  return useQuery({
    queryKey: ['catalog', 'ai', 'semantic-analysis', debouncedRequest],
    queryFn: () => catalogAIMLApiClient.performSemanticAnalysis(debouncedRequest!),
    enabled: !!debouncedRequest && (options?.enabled !== false),
    staleTime: 300000, // 5 minutes
    retry: 2,
  });
}

/**
 * Hook for generating semantic embeddings
 */
export function useGenerateEmbeddings(
  text: string | null,
  options?: {
    enabled?: boolean;
    model?: string;
  }
): UseQueryResult<SemanticEmbedding, Error> {
  const [debouncedText] = useDebounce(text, 300);

  return useQuery({
    queryKey: ['catalog', 'ai', 'embeddings', debouncedText, options?.model],
    queryFn: () => catalogAIMLApiClient.generateEmbeddings(debouncedText!, options?.model),
    enabled: !!debouncedText && (options?.enabled !== false),
    staleTime: 600000, // 10 minutes
  });
}

/**
 * Hook for calculating semantic similarity
 */
export function useCalculateSimilarity(
  request: SimilarityCalculationRequest | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<SimilarityScore[], Error> {
  return useQuery({
    queryKey: ['catalog', 'ai', 'similarity', request],
    queryFn: () => catalogAIMLApiClient.calculateSimilarity(request!),
    enabled: !!request && (options?.enabled !== false),
    staleTime: 300000,
  });
}

/**
 * Hook for extracting relationships
 */
export function useExtractRelationships(
  request: RelationshipExtractionRequest | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<ExtractedRelationship[], Error> {
  return useQuery({
    queryKey: ['catalog', 'ai', 'relationships', request],
    queryFn: () => catalogAIMLApiClient.extractRelationships(request!),
    enabled: !!request && (options?.enabled !== false),
    staleTime: 600000,
  });
}

/**
 * Hook for auto-generating asset descriptions
 */
export function useAutoGenerateDescription(
  request: AutoDescriptionRequest | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<GeneratedDescription, Error> {
  return useQuery({
    queryKey: ['catalog', 'ai', 'auto-description', request],
    queryFn: () => catalogAIMLApiClient.autoGenerateDescription(request!),
    enabled: !!request && (options?.enabled !== false),
    staleTime: 300000,
  });
}

// ===================== RECOMMENDATION HOOKS =====================

/**
 * Hook for getting asset recommendations
 */
export function useAssetRecommendations(
  request: AssetRecommendationRequest | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<AssetRecommendation[], Error> {
  return useQuery({
    queryKey: ['catalog', 'ai', 'recommendations', request],
    queryFn: () => catalogAIMLApiClient.getAssetRecommendations(request!),
    enabled: !!request && (options?.enabled !== false),
    refetchInterval: 300000, // 5 minutes
    staleTime: 180000, // 3 minutes
  });
}

/**
 * Hook for getting intelligent recommendations
 */
export function useIntelligentRecommendations(
  assetId: string | null,
  context?: any,
  options?: {
    enabled?: boolean;
    limit?: number;
  }
): UseQueryResult<AssetRecommendation[], Error> {
  return useQuery({
    queryKey: ['catalog', 'ai', 'intelligent-recommendations', assetId, context],
    queryFn: () => catalogAIMLApiClient.getIntelligentRecommendations(assetId!, context, options?.limit),
    enabled: !!assetId && (options?.enabled !== false),
    staleTime: 300000,
  });
}

// ===================== CLASSIFICATION HOOKS =====================

/**
 * Hook for auto-classification
 */
export function useAutoClassification(
  request: AutoClassificationRequest | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<AutoClassificationResult, Error> {
  return useQuery({
    queryKey: ['catalog', 'ai', 'auto-classification', request],
    queryFn: () => catalogAIMLApiClient.autoClassifyAsset(request!),
    enabled: !!request && (options?.enabled !== false),
    staleTime: 180000,
  });
}

/**
 * Hook for sensitive data detection
 */
export function useSensitiveDataDetection(
  request: SensitiveDataDetectionRequest | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<SensitiveDataDetectionResult, Error> {
  return useQuery({
    queryKey: ['catalog', 'ai', 'sensitive-data', request],
    queryFn: () => catalogAIMLApiClient.detectSensitiveData(request!),
    enabled: !!request && (options?.enabled !== false),
    staleTime: 300000,
  });
}

// ===================== PATTERN RECOGNITION HOOKS =====================

/**
 * Hook for pattern recognition
 */
export function usePatternRecognition(
  request: PatternRecognitionRequest | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<RecognizedPattern[], Error> {
  return useQuery({
    queryKey: ['catalog', 'ai', 'pattern-recognition', request],
    queryFn: () => catalogAIMLApiClient.recognizePatterns(request!),
    enabled: !!request && (options?.enabled !== false),
    staleTime: 600000,
  });
}

/**
 * Hook for anomaly detection
 */
export function useAnomalyDetection(
  request: AnomalyDetectionRequest | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<DetectedAnomaly[], Error> {
  return useQuery({
    queryKey: ['catalog', 'ai', 'anomaly-detection', request],
    queryFn: () => catalogAIMLApiClient.detectAnomalies(request!),
    enabled: !!request && (options?.enabled !== false),
    refetchInterval: 120000, // 2 minutes
    staleTime: 60000,
  });
}

/**
 * Hook for schema evolution detection
 */
export function useSchemaEvolutionDetection(
  request: SchemaEvolutionDetectionRequest | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<SchemaEvolutionResult, Error> {
  return useQuery({
    queryKey: ['catalog', 'ai', 'schema-evolution', request],
    queryFn: () => catalogAIMLApiClient.detectSchemaEvolution(request!),
    enabled: !!request && (options?.enabled !== false),
    staleTime: 600000,
  });
}

// ===================== PREDICTIVE ANALYTICS HOOKS =====================

/**
 * Hook for predictive analytics
 */
export function usePredictiveAnalytics(
  request: PredictiveAnalyticsRequest | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<PredictiveInsight[], Error> {
  return useQuery({
    queryKey: ['catalog', 'ai', 'predictive-analytics', request],
    queryFn: () => catalogAIMLApiClient.getPredictiveAnalytics(request!),
    enabled: !!request && (options?.enabled !== false),
    staleTime: 600000,
  });
}

/**
 * Hook for contextual intelligence
 */
export function useContextualIntelligence(
  request: ContextualIntelligenceRequest | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<ContextualInsight, Error> {
  return useQuery({
    queryKey: ['catalog', 'ai', 'contextual-intelligence', request],
    queryFn: () => catalogAIMLApiClient.getContextualIntelligence(request!),
    enabled: !!request && (options?.enabled !== false),
    staleTime: 300000,
  });
}

// ===================== ML MODEL HOOKS =====================

/**
 * Hook for getting ML models
 */
export function useMLModels(
  filters?: {
    type?: string;
    status?: string;
    version?: string;
  },
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<MLModel[], Error> {
  return useQuery({
    queryKey: ['catalog', 'ml', 'models', filters],
    queryFn: () => catalogAIMLApiClient.getMLModels(filters),
    enabled: options?.enabled !== false,
    staleTime: 300000,
  });
}

/**
 * Hook for getting specific ML model
 */
export function useMLModel(
  modelId: string | null,
  options?: {
    enabled?: boolean;
    includeMetrics?: boolean;
  }
): UseQueryResult<MLModel, Error> {
  return useQuery({
    queryKey: ['catalog', 'ml', 'model', modelId, options?.includeMetrics],
    queryFn: () => catalogAIMLApiClient.getMLModel(modelId!, options?.includeMetrics),
    enabled: !!modelId && (options?.enabled !== false),
    staleTime: 300000,
  });
}

/**
 * Hook for ML model metrics
 */
export function useMLModelMetrics(
  modelId: string | null,
  options?: {
    enabled?: boolean;
    timeRange?: string;
  }
): UseQueryResult<MLModelMetrics, Error> {
  return useQuery({
    queryKey: ['catalog', 'ml', 'model-metrics', modelId, options?.timeRange],
    queryFn: () => catalogAIMLApiClient.getMLModelMetrics(modelId!, options?.timeRange),
    enabled: !!modelId && (options?.enabled !== false),
    refetchInterval: 60000,
    staleTime: 30000,
  });
}

/**
 * Hook for ML model predictions
 */
export function useMLModelPredictions(
  modelId: string | null,
  inputData: any,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<MLModelPrediction, Error> {
  return useQuery({
    queryKey: ['catalog', 'ml', 'predictions', modelId, inputData],
    queryFn: () => catalogAIMLApiClient.makePrediction(modelId!, inputData),
    enabled: !!modelId && !!inputData && (options?.enabled !== false),
    staleTime: 60000,
  });
}

/**
 * Hook for model registry
 */
export function useModelRegistry(
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<ModelRegistry, Error> {
  return useQuery({
    queryKey: ['catalog', 'ml', 'model-registry'],
    queryFn: () => catalogAIMLApiClient.getModelRegistry(),
    enabled: options?.enabled !== false,
    staleTime: 600000,
  });
}

/**
 * Hook for feature store
 */
export function useFeatureStore(
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<FeatureStore, Error> {
  return useQuery({
    queryKey: ['catalog', 'ml', 'feature-store'],
    queryFn: () => catalogAIMLApiClient.getFeatureStore(),
    enabled: options?.enabled !== false,
    staleTime: 300000,
  });
}

// ===================== MODEL MONITORING HOOKS =====================

/**
 * Hook for data drift detection
 */
export function useDataDriftDetection(
  modelId: string | null,
  options?: {
    enabled?: boolean;
    timeRange?: string;
  }
): UseQueryResult<DataDrift, Error> {
  return useQuery({
    queryKey: ['catalog', 'ml', 'data-drift', modelId, options?.timeRange],
    queryFn: () => catalogAIMLApiClient.detectDataDrift(modelId!, options?.timeRange),
    enabled: !!modelId && (options?.enabled !== false),
    refetchInterval: 300000, // 5 minutes
    staleTime: 180000,
  });
}

/**
 * Hook for model drift detection
 */
export function useModelDriftDetection(
  modelId: string | null,
  options?: {
    enabled?: boolean;
    timeRange?: string;
  }
): UseQueryResult<ModelDrift, Error> {
  return useQuery({
    queryKey: ['catalog', 'ml', 'model-drift', modelId, options?.timeRange],
    queryFn: () => catalogAIMLApiClient.detectModelDrift(modelId!, options?.timeRange),
    enabled: !!modelId && (options?.enabled !== false),
    refetchInterval: 300000,
    staleTime: 180000,
  });
}

/**
 * Hook for model explainability
 */
export function useModelExplainability(
  modelId: string | null,
  predictionId?: string,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<ModelExplainability, Error> {
  return useQuery({
    queryKey: ['catalog', 'ml', 'explainability', modelId, predictionId],
    queryFn: () => catalogAIMLApiClient.getModelExplainability(modelId!, predictionId),
    enabled: !!modelId && (options?.enabled !== false),
    staleTime: 600000,
  });
}

/**
 * Hook for bias detection
 */
export function useBiasDetection(
  modelId: string | null,
  options?: {
    enabled?: boolean;
    protectedAttributes?: string[];
  }
): UseQueryResult<BiasDetection, Error> {
  return useQuery({
    queryKey: ['catalog', 'ml', 'bias-detection', modelId, options?.protectedAttributes],
    queryFn: () => catalogAIMLApiClient.detectBias(modelId!, options?.protectedAttributes),
    enabled: !!modelId && (options?.enabled !== false),
    staleTime: 3600000, // 1 hour
  });
}

/**
 * Hook for fairness metrics
 */
export function useFairnessMetrics(
  modelId: string | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<FairnessMetrics, Error> {
  return useQuery({
    queryKey: ['catalog', 'ml', 'fairness-metrics', modelId],
    queryFn: () => catalogAIMLApiClient.getFairnessMetrics(modelId!),
    enabled: !!modelId && (options?.enabled !== false),
    staleTime: 3600000,
  });
}

// ===================== AI/ML MUTATION HOOKS =====================

/**
 * Hook for training ML models
 */
export function useTrainMLModel() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: catalogAIMLApiClient.trainMLModel,
    onSuccess: (data, variables) => {
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: ['catalog', 'ml', 'models'] });
      
      toast({
        title: "Model Training Started",
        description: `Training initiated for model: ${variables.name}`,
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error Training Model",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}

/**
 * Hook for deploying ML models
 */
export function useDeployMLModel() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: catalogAIMLApiClient.deployMLModel,
    onSuccess: (data, variables) => {
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: ['catalog', 'ml'] });
      
      toast({
        title: "Model Deployed",
        description: `Successfully deployed model: ${variables.modelId}`,
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error Deploying Model",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}

/**
 * Hook for updating ML model configuration
 */
export function useUpdateMLModelConfig() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: catalogAIMLApiClient.updateMLModelConfig,
    onSuccess: (data, variables) => {
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: ['catalog', 'ml', 'model', variables.modelId] });
      
      toast({
        title: "Model Configuration Updated",
        description: `Successfully updated configuration for model: ${variables.modelId}`,
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error Updating Model Configuration",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}

/**
 * Hook for retraining ML models
 */
export function useRetrainMLModel() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: catalogAIMLApiClient.retrainMLModel,
    onSuccess: (data, variables) => {
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: ['catalog', 'ml'] });
      
      toast({
        title: "Model Retraining Started",
        description: `Retraining initiated for model: ${variables.modelId}`,
      });
    },
    onError: (error: Error) => {
      toast({
        title: "Error Retraining Model",
        description: error.message,
        variant: "destructive",
      });
    },
  });
}

// ===================== REAL-TIME AI HOOKS =====================

/**
 * Hook for real-time AI insights
 */
export function useRealTimeAIInsights(filters?: any) {
  const [insights, setInsights] = useState<AIInsight[]>([]);
  const wsRef = useRef<(() => void) | null>(null);

  useEffect(() => {
    // Subscribe to real-time AI insights
    const unsubscribe = catalogAIMLApiClient.subscribeToAIInsights(
      filters,
      (insight: AIInsight) => {
        setInsights(prev => [insight, ...prev.slice(0, 99)]); // Keep last 100 insights
      }
    );

    wsRef.current = unsubscribe;

    return () => {
      if (unsubscribe) {
        unsubscribe();
      }
    };
  }, [filters]);

  const clearInsights = useCallback(() => {
    setInsights([]);
  }, []);

  return {
    insights,
    clearInsights,
    isConnected: !!wsRef.current,
  };
}

/**
 * Hook for ML pipeline monitoring
 */
export function useMLPipelineMonitoring(
  pipelineId: string | null,
  options?: {
    enabled?: boolean;
  }
): UseQueryResult<MLPipeline, Error> {
  return useQuery({
    queryKey: ['catalog', 'ml', 'pipeline', pipelineId],
    queryFn: () => catalogAIMLApiClient.getMLPipeline(pipelineId!),
    enabled: !!pipelineId && (options?.enabled !== false),
    refetchInterval: 30000,
    staleTime: 15000,
  });
}

/**
 * Comprehensive hook combining all AI/ML operations
 */
export function useCatalogAIML() {
  const queryClient = useQueryClient();

  // Core mutations
  const trainModel = useTrainMLModel();
  const deployModel = useDeployMLModel();
  const updateModelConfig = useUpdateMLModelConfig();
  const retrainModel = useRetrainMLModel();

  // Utility functions
  const invalidateAIMLQueries = useCallback(() => {
    queryClient.invalidateQueries({ queryKey: ['catalog', 'ai'] });
    queryClient.invalidateQueries({ queryKey: ['catalog', 'ml'] });
  }, [queryClient]);

  const prefetchModelMetrics = useCallback(
    (modelId: string) => {
      queryClient.prefetchQuery({
        queryKey: ['catalog', 'ml', 'model-metrics', modelId],
        queryFn: () => catalogAIMLApiClient.getMLModelMetrics(modelId),
        staleTime: 60000,
      });
    },
    [queryClient]
  );

  return {
    // Mutations
    trainModel,
    deployModel,
    updateModelConfig,
    retrainModel,

    // Utilities
    invalidateAIMLQueries,
    prefetchModelMetrics,

    // Status checks
    isTraining: trainModel.isPending,
    isDeploying: deployModel.isPending,
    isUpdatingConfig: updateModelConfig.isPending,
    isRetraining: retrainModel.isPending,
    hasError: trainModel.isError || deployModel.isError || updateModelConfig.isError || retrainModel.isError,
  };
}

export default useCatalogAIML;