from fastapi import APIRouter, Depends, HTTPException, WebSocket, WebSocketDisconnect
from sqlalchemy.orm import Session
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field
import uuid
from datetime import datetime

from ...services.ai_service import AIIntelligentClassificationService
from ...models.ai_models import (
    AIModel, IntelligentAssistantSession, AssistantInteraction, AIInsight,
    DomainIntelligence, ContextAwareSearch, AutoGeneratedTag,
    AIOptimizationRecommendation, ExplainableAITrace,
    AIModelType, IntelligenceLevel, InsightType, RecommendationPriority
)
from ...utils.db import get_db

router = APIRouter(prefix="/ai-classification", tags=["AI Classification"])

# Pydantic Schemas for AI endpoints
class AIModelCreate(BaseModel):
    name: str = Field(..., description="AI model name")
    description: Optional[str] = Field(None, description="Model description")
    model_type: AIModelType = Field(..., description="Type of AI model")
    architecture_details: Dict[str, Any] = Field(default_factory=dict, description="Architecture details")
    parameter_count: int = Field(default=0, description="Number of parameters in billions")
    context_window_size: int = Field(default=4096, description="Context window size")
    capabilities: List[str] = Field(default_factory=list, description="AI capabilities")
    intelligence_level: IntelligenceLevel = Field(default=IntelligenceLevel.ADVANCED, description="Intelligence level")
    specialized_domains: List[str] = Field(default_factory=list, description="Specialized domains")
    api_endpoint: str = Field(default="", description="API endpoint for the model")
    cost_per_request: float = Field(default=0.0, description="Cost per request")

class AIModelResponse(BaseModel):
    id: int
    uuid: str
    name: str
    description: Optional[str]
    model_type: str
    intelligence_level: str
    specialized_domains: List[str]
    parameter_count: int
    context_window_size: int
    api_endpoint: str
    cost_per_request: float
    created_at: datetime
    created_by: str

class AssistantSessionCreate(BaseModel):
    ai_model_id: int = Field(..., description="ID of the AI model to use")
    domain_context: Dict[str, Any] = Field(default_factory=dict, description="Domain context")
    entity_context: Dict[str, Any] = Field(default_factory=dict, description="Entity context")
    user_preferences: Dict[str, Any] = Field(default_factory=dict, description="User preferences")

class AssistantSessionResponse(BaseModel):
    id: int
    uuid: str
    ai_model_id: int
    user_id: str
    session_name: str
    domain_context: Dict[str, Any]
    entity_context: Dict[str, Any]
    is_active: bool
    total_interactions: int
    user_satisfaction_score: Optional[float]
    created_at: datetime

class IntelligentQueryRequest(BaseModel):
    session_id: str = Field(..., description="Assistant session UUID")
    user_input: str = Field(..., description="User query or command")
    context: Dict[str, Any] = Field(default_factory=dict, description="Additional context")

class IntelligentQueryResponse(BaseModel):
    id: int
    session_id: int
    user_input: str
    assistant_response: str
    interaction_type: str
    detected_intent: Optional[str]
    entities_extracted: Dict[str, Any]
    confidence_score: float
    reasoning_chain: List[Dict[str, Any]]
    sources_cited: List[str]
    uncertainty_indicators: Dict[str, Any]
    response_time_ms: float
    tokens_used: int
    cost_incurred: float
    created_at: datetime

class InsightGenerationRequest(BaseModel):
    ai_model_id: int = Field(..., description="ID of the AI model to use")
    entity_type: str = Field(..., description="Type of entity")
    entity_id: str = Field(..., description="ID of the entity")
    entity_data: Dict[str, Any] = Field(..., description="Entity data for analysis")

class InsightResponse(BaseModel):
    id: int
    uuid: str
    ai_model_id: int
    title: str
    description: str
    insight_type: str
    priority: str
    entity_type: str
    entity_id: str
    key_findings: Dict[str, Any]
    recommendations: Dict[str, Any]
    risk_assessment: Dict[str, Any]
    business_impact: Dict[str, Any]
    confidence_score: float
    reasoning_explanation: str
    action_items: List[Dict[str, Any]]
    estimated_effort: str
    urgency_level: str
    created_at: datetime
    generated_by: str

class ContextSearchRequest(BaseModel):
    query: str = Field(..., description="Search query")
    user_context: Dict[str, Any] = Field(default_factory=dict, description="User context")
    entity_context: Dict[str, Any] = Field(default_factory=dict, description="Entity context")
    temporal_context: Dict[str, Any] = Field(default_factory=dict, description="Temporal context")
    domain_context: Dict[str, Any] = Field(default_factory=dict, description="Domain context")

class ContextSearchResponse(BaseModel):
    id: int
    uuid: str
    query_text: str
    user_id: str
    search_intent: str
    results: List[Dict[str, Any]]
    result_count: int
    search_time_ms: float
    relevance_score: float
    created_at: datetime

class AutoTagRequest(BaseModel):
    entity_type: str = Field(..., description="Type of entity")
    entity_id: str = Field(..., description="ID of the entity")
    entity_data: Dict[str, Any] = Field(..., description="Entity data for tag generation")

class AutoTagResponse(BaseModel):
    id: int
    entity_type: str
    entity_id: str
    tag_name: str
    tag_value: Optional[str]
    tag_category: str
    generation_method: str
    confidence_score: float
    reasoning: str
    is_validated: bool
    created_at: datetime
    generated_by: str

class OptimizationRequest(BaseModel):
    target_system: str = Field(..., description="Target system for optimization")
    target_component: Optional[str] = Field(None, description="Specific component")
    current_state: Dict[str, Any] = Field(..., description="Current state analysis")
    analysis_data: Dict[str, Any] = Field(..., description="Analysis data")

class OptimizationResponse(BaseModel):
    id: int
    uuid: str
    target_system: str
    target_component: Optional[str]
    optimization_type: str
    current_state: Dict[str, Any]
    recommended_changes: Dict[str, Any]
    expected_improvements: Dict[str, Any]
    implementation_steps: List[Dict[str, Any]]
    estimated_effort_hours: float
    cost_savings_annual: float
    performance_improvement_percentage: float
    roi_months: float
    status: str
    created_at: datetime

class ExplainableTraceRequest(BaseModel):
    decision_id: str = Field(..., description="Unique decision identifier")
    model_used: str = Field(..., description="Model that made the decision")
    input_data: Dict[str, Any] = Field(..., description="Input data for the decision")
    decision_data: Dict[str, Any] = Field(..., description="Decision context and data")

class ExplainableTraceResponse(BaseModel):
    id: int
    decision_id: str
    model_used: str
    input_data: Dict[str, Any]
    feature_importance: Dict[str, Any]
    attention_weights: Dict[str, Any]
    reasoning_steps: List[Dict[str, Any]]
    alternative_paths_considered: List[Dict[str, Any]]
    confidence_intervals: Dict[str, Any]
    decision_rationale: str
    key_factors: List[str]
    uncertainty_sources: List[str]
    human_review_status: Optional[str]
    created_at: datetime
    decision_maker: str

# Initialize AI service
ai_service = AIIntelligentClassificationService()

@router.post("/models", response_model=AIModelResponse)
async def create_ai_model(
    model: AIModelCreate,
    user: str,
    db: Session = Depends(get_db)
):
    """Create a new AI model configuration"""
    try:
        ai_model = await ai_service.create_ai_model(db, model.dict(), user)
        return AIModelResponse(
            id=ai_model.id,
            uuid=str(ai_model.uuid),
            name=ai_model.name,
            description=ai_model.description,
            model_type=ai_model.model_type.value,
            intelligence_level=ai_model.intelligence_level.value,
            specialized_domains=ai_model.specialized_domains or [],
            parameter_count=ai_model.parameter_count,
            context_window_size=ai_model.context_window_size,
            api_endpoint=ai_model.api_endpoint,
            cost_per_request=ai_model.cost_per_request,
            created_at=ai_model.created_at,
            created_by=ai_model.created_by
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/models", response_model=List[AIModelResponse])
async def list_ai_models(
    model_type: Optional[AIModelType] = None,
    intelligence_level: Optional[IntelligenceLevel] = None,
    limit: int = 50,
    db: Session = Depends(get_db)
):
    """List AI models with optional filtering"""
    try:
        query = db.query(AIModel)
        
        if model_type:
            query = query.filter(AIModel.model_type == model_type)
        if intelligence_level:
            query = query.filter(AIModel.intelligence_level == intelligence_level)
        
        models = query.limit(limit).all()
        
        return [
            AIModelResponse(
                id=model.id,
                uuid=str(model.uuid),
                name=model.name,
                description=model.description,
                model_type=model.model_type.value,
                intelligence_level=model.intelligence_level.value,
                specialized_domains=model.specialized_domains or [],
                parameter_count=model.parameter_count,
                context_window_size=model.context_window_size,
                api_endpoint=model.api_endpoint,
                cost_per_request=model.cost_per_request,
                created_at=model.created_at,
                created_by=model.created_by
            )
            for model in models
        ]
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/assistant/sessions", response_model=AssistantSessionResponse)
async def start_assistant_session(
    session_req: AssistantSessionCreate,
    user_id: str,
    db: Session = Depends(get_db)
):
    """Start a new intelligent assistant session"""
    try:
        context = {
            'domain_context': session_req.domain_context,
            'entity_context': session_req.entity_context,
            'user_preferences': session_req.user_preferences
        }
        
        session = await ai_service.start_intelligent_session(
            db, session_req.ai_model_id, user_id, context
        )
        
        return AssistantSessionResponse(
            id=session.id,
            uuid=str(session.uuid),
            ai_model_id=session.ai_model_id,
            user_id=session.user_id,
            session_name=session.session_name,
            domain_context=session.domain_context or {},
            entity_context=session.entity_context or {},
            is_active=session.is_active,
            total_interactions=session.total_interactions,
            user_satisfaction_score=session.user_satisfaction_score,
            created_at=session.created_at
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/assistant/query", response_model=IntelligentQueryResponse)
async def process_intelligent_query(
    query: IntelligentQueryRequest,
    db: Session = Depends(get_db)
):
    """Process an intelligent query through the AI assistant"""
    try:
        interaction = await ai_service.process_intelligent_query(
            db, query.session_id, query.user_input, query.context
        )
        
        return IntelligentQueryResponse(
            id=interaction.id,
            session_id=interaction.session_id,
            user_input=interaction.user_input,
            assistant_response=interaction.assistant_response,
            interaction_type=interaction.interaction_type,
            detected_intent=interaction.detected_intent,
            entities_extracted=interaction.entities_extracted or {},
            confidence_score=interaction.confidence_score,
            reasoning_chain=interaction.reasoning_chain or [],
            sources_cited=interaction.sources_cited or [],
            uncertainty_indicators=interaction.uncertainty_indicators or {},
            response_time_ms=interaction.response_time_ms,
            tokens_used=interaction.tokens_used,
            cost_incurred=interaction.cost_incurred,
            created_at=interaction.created_at
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.websocket("/assistant/ws/{session_id}")
async def websocket_assistant(websocket: WebSocket, session_id: str, db: Session = Depends(get_db)):
    """WebSocket endpoint for real-time assistant interaction"""
    await websocket.accept()
    
    try:
        while True:
            # Receive message from client
            data = await websocket.receive_json()
            user_input = data.get('message', '')
            context = data.get('context', {})
            
            # Process query
            interaction = await ai_service.process_intelligent_query(
                db, session_id, user_input, context
            )
            
            # Send response back to client
            response_data = {
                'type': 'assistant_response',
                'interaction_id': interaction.id,
                'response': interaction.assistant_response,
                'intent': interaction.detected_intent,
                'confidence': interaction.confidence_score,
                'reasoning': interaction.reasoning_chain or [],
                'sources': interaction.sources_cited or [],
                'response_time_ms': interaction.response_time_ms
            }
            
            await websocket.send_json(response_data)
            
    except WebSocketDisconnect:
        print(f"WebSocket disconnected for session {session_id}")
    except Exception as e:
        await websocket.send_json({
            'type': 'error',
            'message': str(e)
        })

@router.post("/insights", response_model=List[InsightResponse])
async def generate_ai_insights(
    request: InsightGenerationRequest,
    user: str,
    db: Session = Depends(get_db)
):
    """Generate AI-powered insights for data entities"""
    try:
        insights = await ai_service.generate_ai_insights(
            db, request.ai_model_id, request.entity_type, request.entity_id, request.entity_data, user
        )
        
        return [
            InsightResponse(
                id=insight.id,
                uuid=str(insight.uuid),
                ai_model_id=insight.ai_model_id,
                title=insight.title,
                description=insight.description,
                insight_type=insight.insight_type.value,
                priority=insight.priority.value,
                entity_type=insight.entity_type,
                entity_id=insight.entity_id,
                key_findings=insight.key_findings or {},
                recommendations=insight.recommendations or {},
                risk_assessment=insight.risk_assessment or {},
                business_impact=insight.business_impact or {},
                confidence_score=insight.confidence_score,
                reasoning_explanation=insight.reasoning_explanation or "",
                action_items=insight.action_items or [],
                estimated_effort=insight.estimated_effort or "medium",
                urgency_level=insight.urgency_level or "medium",
                created_at=insight.created_at,
                generated_by=insight.generated_by
            )
            for insight in insights
        ]
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/search", response_model=ContextSearchResponse)
async def context_aware_search(
    search_req: ContextSearchRequest,
    user_id: str,
    db: Session = Depends(get_db)
):
    """Perform context-aware intelligent search"""
    try:
        context = {
            'user_context': search_req.user_context,
            'entity_context': search_req.entity_context,
            'temporal_context': search_req.temporal_context,
            'domain_context': search_req.domain_context
        }
        
        search_result = await ai_service.perform_context_aware_search(
            db, search_req.query, user_id, context
        )
        
        return ContextSearchResponse(
            id=search_result.id,
            uuid=str(search_result.uuid),
            query_text=search_result.query_text,
            user_id=search_result.user_id,
            search_intent=search_result.search_intent or "unknown",
            results=search_result.results or [],
            result_count=search_result.result_count,
            search_time_ms=search_result.search_time_ms,
            relevance_score=search_result.relevance_score or 0.0,
            created_at=search_result.created_at
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/auto-tag", response_model=List[AutoTagResponse])
async def auto_generate_tags(
    request: AutoTagRequest,
    user: str,
    db: Session = Depends(get_db)
):
    """Auto-generate intelligent tags using AI"""
    try:
        tags = await ai_service.auto_generate_tags(
            db, request.entity_type, request.entity_id, request.entity_data, user
        )
        
        return [
            AutoTagResponse(
                id=tag.id,
                entity_type=tag.entity_type,
                entity_id=tag.entity_id,
                tag_name=tag.tag_name,
                tag_value=tag.tag_value,
                tag_category=tag.tag_category,
                generation_method=tag.generation_method,
                confidence_score=tag.confidence_score,
                reasoning=tag.reasoning or "",
                is_validated=tag.is_validated,
                created_at=tag.created_at,
                generated_by=tag.generated_by
            )
            for tag in tags
        ]
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/optimization", response_model=OptimizationResponse)
async def create_optimization_recommendation(
    request: OptimizationRequest,
    user: str,
    db: Session = Depends(get_db)
):
    """Create AI-powered optimization recommendations"""
    try:
        analysis_data = {
            'target_component': request.target_component,
            'current_state': request.current_state,
            **request.analysis_data
        }
        
        recommendation = await ai_service.create_optimization_recommendation(
            db, request.target_system, analysis_data, user
        )
        
        return OptimizationResponse(
            id=recommendation.id,
            uuid=str(recommendation.uuid),
            target_system=recommendation.target_system,
            target_component=recommendation.target_component,
            optimization_type=recommendation.optimization_type,
            current_state=recommendation.current_state or {},
            recommended_changes=recommendation.recommended_changes or {},
            expected_improvements=recommendation.expected_improvements or {},
            implementation_steps=recommendation.implementation_steps or [],
            estimated_effort_hours=recommendation.estimated_effort_hours or 0.0,
            cost_savings_annual=recommendation.cost_savings_annual or 0.0,
            performance_improvement_percentage=recommendation.performance_improvement_percentage or 0.0,
            roi_months=recommendation.roi_months or 12.0,
            status=recommendation.status,
            created_at=recommendation.created_at
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/explainable-trace", response_model=ExplainableTraceResponse)
async def create_explainable_trace(
    request: ExplainableTraceRequest,
    user: str,
    db: Session = Depends(get_db)
):
    """Create explainable AI trace for transparency"""
    try:
        trace = await ai_service.create_explainable_trace(
            db, request.decision_id, request.model_used, request.decision_data, user
        )
        
        return ExplainableTraceResponse(
            id=trace.id,
            decision_id=trace.decision_id,
            model_used=trace.model_used,
            input_data=trace.input_data or {},
            feature_importance=trace.feature_importance or {},
            attention_weights=trace.attention_weights or {},
            reasoning_steps=trace.reasoning_steps or [],
            alternative_paths_considered=trace.alternative_paths_considered or [],
            confidence_intervals=trace.confidence_intervals or {},
            decision_rationale=trace.decision_rationale,
            key_factors=trace.key_factors or [],
            uncertainty_sources=trace.uncertainty_sources or [],
            human_review_status=trace.human_review_status,
            created_at=trace.created_at,
            decision_maker=trace.decision_maker
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/insights", response_model=List[InsightResponse])
async def list_insights(
    entity_type: Optional[str] = None,
    entity_id: Optional[str] = None,
    insight_type: Optional[InsightType] = None,
    priority: Optional[RecommendationPriority] = None,
    limit: int = 50,
    db: Session = Depends(get_db)
):
    """List AI insights with optional filtering"""
    try:
        query = db.query(AIInsight)
        
        if entity_type:
            query = query.filter(AIInsight.entity_type == entity_type)
        if entity_id:
            query = query.filter(AIInsight.entity_id == entity_id)
        if insight_type:
            query = query.filter(AIInsight.insight_type == insight_type)
        if priority:
            query = query.filter(AIInsight.priority == priority)
        
        insights = query.order_by(AIInsight.created_at.desc()).limit(limit).all()
        
        return [
            InsightResponse(
                id=insight.id,
                uuid=str(insight.uuid),
                ai_model_id=insight.ai_model_id,
                title=insight.title,
                description=insight.description,
                insight_type=insight.insight_type.value,
                priority=insight.priority.value,
                entity_type=insight.entity_type,
                entity_id=insight.entity_id,
                key_findings=insight.key_findings or {},
                recommendations=insight.recommendations or {},
                risk_assessment=insight.risk_assessment or {},
                business_impact=insight.business_impact or {},
                confidence_score=insight.confidence_score,
                reasoning_explanation=insight.reasoning_explanation or "",
                action_items=insight.action_items or [],
                estimated_effort=insight.estimated_effort or "medium",
                urgency_level=insight.urgency_level or "medium",
                created_at=insight.created_at,
                generated_by=insight.generated_by
            )
            for insight in insights
        ]
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/assistant/sessions", response_model=List[AssistantSessionResponse])
async def list_assistant_sessions(
    user_id: Optional[str] = None,
    ai_model_id: Optional[int] = None,
    is_active: Optional[bool] = None,
    limit: int = 50,
    db: Session = Depends(get_db)
):
    """List assistant sessions with optional filtering"""
    try:
        query = db.query(IntelligentAssistantSession)
        
        if user_id:
            query = query.filter(IntelligentAssistantSession.user_id == user_id)
        if ai_model_id:
            query = query.filter(IntelligentAssistantSession.ai_model_id == ai_model_id)
        if is_active is not None:
            query = query.filter(IntelligentAssistantSession.is_active == is_active)
        
        sessions = query.order_by(IntelligentAssistantSession.created_at.desc()).limit(limit).all()
        
        return [
            AssistantSessionResponse(
                id=session.id,
                uuid=str(session.uuid),
                ai_model_id=session.ai_model_id,
                user_id=session.user_id,
                session_name=session.session_name,
                domain_context=session.domain_context or {},
                entity_context=session.entity_context or {},
                is_active=session.is_active,
                total_interactions=session.total_interactions,
                user_satisfaction_score=session.user_satisfaction_score,
                created_at=session.created_at
            )
            for session in sessions
        ]
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))